<?xml version="1.0" encoding="utf-8"?>
<issues>
  <issue>
    <field name="Priority">
      <value>Major</value>
    </field>
    <field name="Type">
      <value>Bug</value>
    </field>
    <field name="State">
      <value>Fixed</value>
    </field>
    <field name="Assignee" />
    <field name="Subsystem">
      <value>NHibernate</value>
    </field>
    <field name="Fix versions">
      <value>Future</value>
    </field>
    <field name="Affected versions">
      <value>Future</value>
    </field>
    <field name="Fixed in build" />
    <field name="numberInProject">
      <value>103</value>
    </field>
    <field name="summary">
      <value>DefaultSessionManager should remove session from session store if transaction enlistment fails</value>
    </field>
    <field name="description">
      <value>In the current DefaultSessionManager implementation, if an exception is thrown when a session in enlisted in a transaction, the session is left in the session store. (This may occur when network connectivity to the database [SQL Server] is lost and ISession.BeginTransaction throws an exception.) This transaction fails as it should, but the problem is that all future transactions that use this session store also fail (since the zombie session stays in the session store and future transactions get the zombie session). This is particularly bad when using the TLSActivityManager and the ThreadPool, since now some arbitrary worker thread can no longer process transactions.

Probably the right (99%) fix is to swap the order: enlist in transaction and then store the session (does this break anything else?).

if (wrapped == null)
{
  session = CreateSession(alias); weAreSessionOwner = true;

  wrapped = WrapSession(transaction != null, session);

  EnlistIfNecessary(weAreSessionOwner, transaction, wrapped);

  sessionStore.Store(alias, wrapped);
}

If swapping the order is too risky, the next best fix is to catch exceptions coming out of EnlistIfNecessary, remove the session from the session store, and rethrow.

if (wrapped == null)
{
  session = CreateSession(alias); weAreSessionOwner = true;

  wrapped = WrapSession(transaction != null, session);

  sessionStore.Store(alias, wrapped);

  try
  {
    EnlistIfNecessary(weAreSessionOwner, transaction, wrapped);
  }
  catch
  {
    sessionStore.Remove(wrapped);
    throw;
  }
}

Here's the beginnings of a test case to prevent regression.

_________________________________________________________________________

using System;
using System.Collections;
using System.Data;
using System.Data.Common;
using Castle.Facilities.NHibernateIntegration.Internal;
using Castle.MicroKernel;
using Castle.Services.Transaction;
using NHibernate;
using NUnit.Framework;
using Rhino.Mocks;
using ITransaction = Castle.Services.Transaction.ITransaction;

namespace Castle.Facilities.NHibernateIntegration.Tests
{
    [TestFixture]
    public class DefaultSessionManagerTestCase
    {
        const string Alias = "myAlias";
        const string InterceptorFormatString = "nhibernate.session.interceptor.{0}";
        const string InterceptorName = "nhibernate.session.interceptor";
        const IsolationMode DefaultIsolationMode = IsolationMode.ReadUncommitted;
        const IsolationLevel DefaultIsolationLevel = IsolationLevel.ReadUncommitted;

        MockRepository mockRepository;

        ISessionStore sessionStore;
        IKernel kernel;
        ISessionFactoryResolver factoryResolver;
        ITransactionManager transactionManager;
        ITransaction transaction;
        ISessionFactory sessionFactory;
        ISession session;
        IDictionary contextDictionary;

        DefaultSessionManager sessionManager;

        T StrictMock&lt;T&gt;()
        {
            return mockRepository.StrictMock&lt;T&gt;();
        }

        [SetUp]
        public void SetUp()
        {
            mockRepository = new MockRepository();

            sessionStore = StrictMock&lt;ISessionStore&gt;();
            kernel = StrictMock&lt;IKernel&gt;();
            factoryResolver = StrictMock&lt;ISessionFactoryResolver&gt;();
            transactionManager = StrictMock&lt;ITransactionManager&gt;();
            transaction = StrictMock&lt;ITransaction&gt;();
            sessionFactory = StrictMock&lt;ISessionFactory&gt;();
            session = StrictMock&lt;ISession&gt;();
            contextDictionary = new Hashtable();

            sessionManager = new DefaultSessionManager(sessionStore, kernel, factoryResolver);
        }

        static void ExpectReturn(object ignored, object returnValue)
        {
            Expect.Call(ignored).Return(returnValue);
        }

        static void ExpectMissingComponent(IKernel kernel, string component)
        {
            ExpectReturn(kernel.HasComponent(component), false);
        }

        Exception CreateException()
        {
            return mockRepository.Stub&lt;DbException&gt;("A transport-level error has occurred when sending the request to the server.");
        }

        [Test]
        public void WhenBeginTransactionFailsSessionIsRemovedFromSessionStore()
        {
            using (mockRepository.Record())
            {
                ExpectReturn(kernel[typeof(ITransactionManager)], transactionManager);
                ExpectReturn(transactionManager.CurrentTransaction, transaction);
                ExpectReturn(sessionStore.FindCompatibleSession(Alias), null);
                ExpectReturn(factoryResolver.GetSessionFactory(Alias), sessionFactory);
                ExpectMissingComponent(kernel, string.Format(InterceptorFormatString, Alias));
                ExpectMissingComponent(kernel, InterceptorName);
                ExpectReturn(sessionFactory.OpenSession(), session);
                session.FlushMode = sessionManager.DefaultFlushMode;
                Expect.Call(transaction.Context).Return(contextDictionary).Repeat.Any();
                ExpectReturn(transaction.DistributedTransaction, false);
                ExpectReturn(transaction.IsolationMode, DefaultIsolationMode);
                Expect.Call(session.BeginTransaction(DefaultIsolationLevel)).Throw(CreateException());
            }

            using (mockRepository.Playback())
            {
                try
                {
                    sessionManager.OpenSession(Alias);
                    Assert.Fail("DbException not thrown");
                }
                catch (DbException)
                {
                }
            }
        }
    }
}

This test also points out that we need to pull out some constants from the main DefaultSessionManager code.</value>
    </field>
    <field name="created">
      <value>1219935586000</value>
    </field>
    <field name="updated">
      <value>1231910777000</value>
    </field>
    <field name="reporterName">
      <value>aaron.armstrong.sungard</value>
    </field>
    <field name="updaterName">
      <value>aaron.armstrong.sungard</value>
    </field>
    <field name="resolved">
      <value>1231910760000</value>
    </field>
    <field name="permittedGroup">
      <value>All Users</value>
    </field>
    <comment author="tehlike" text="Fixed in rev 5404 by Aaron Armstrong" created="1231910760000" />
    <comment author="tehlike" text="Fixed in rev 5404 by Aaron Armstrong" created="1231910777000" />
    <comment author="aaron.armstrong.sungard" text="* '''Description''' changed from:&#xD;&#xA;{quote}&#xD;&#xA;In the current DefaultSessionManager implementation, if an exception is thrown when a session in enlisted in a transaction, the session is left in the session store. (This may occur when network connectivity to the database [SQL Server] is lost and ISession.BeginTransaction throws an exception.) This transaction fails as it should, but the problem is that all future transactions that use this session store also fail (since the zombie session stays in the session store and future transactions get the zombie session). This is particularly bad when using the TLSActivityManager and the ThreadPool, since now some arbitrary worker thread can no longer process transactions.&#xD;&#xA;&#xD;&#xA;The 99% fix is to catch exceptions coming out of EnlistIfNecessary, remove the session from the session store, and rethrow.&#xD;&#xA;&#xD;&#xA;if (wrapped == null)&#xD;&#xA;{&#xD;&#xA;  session = CreateSession(alias); weAreSessionOwner = true;&#xD;&#xA;&#xD;&#xA;  wrapped = WrapSession(transaction != null, session);&#xD;&#xA;&#xD;&#xA;  sessionStore.Store(alias, wrapped);&#xD;&#xA;&#xD;&#xA;  try&#xD;&#xA;  {&#xD;&#xA;    EnlistIfNecessary(weAreSessionOwner, transaction, wrapped);&#xD;&#xA;  }&#xD;&#xA;  catch&#xD;&#xA;  {&#xD;&#xA;    sessionStore.Remove(wrapped);&#xD;&#xA;    throw;&#xD;&#xA;  }&#xD;&#xA;}&#xD;&#xA;{quote}&#xD;&#xA;to:&#xD;&#xA;{quote}&#xD;&#xA;In the current DefaultSessionManager implementation, if an exception is thrown when a session in enlisted in a transaction, the session is left in the session store. (This may occur when network connectivity to the database [SQL Server] is lost and ISession.BeginTransaction throws an exception.) This transaction fails as it should, but the problem is that all future transactions that use this session store also fail (since the zombie session stays in the session store and future transactions get the zombie session). This is particularly bad when using the TLSActivityManager and the ThreadPool, since now some arbitrary worker thread can no longer process transactions.&#xD;&#xA;&#xD;&#xA;The 99% fix is to catch exceptions coming out of EnlistIfNecessary, remove the session from the session store, and rethrow.&#xD;&#xA;&#xD;&#xA;if (wrapped == null)&#xD;&#xA;{&#xD;&#xA;  session = CreateSession(alias); weAreSessionOwner = true;&#xD;&#xA;&#xD;&#xA;  wrapped = WrapSession(transaction != null, session);&#xD;&#xA;&#xD;&#xA;  sessionStore.Store(alias, wrapped);&#xD;&#xA;&#xD;&#xA;  try&#xD;&#xA;  {&#xD;&#xA;    EnlistIfNecessary(weAreSessionOwner, transaction, wrapped);&#xD;&#xA;  }&#xD;&#xA;  catch&#xD;&#xA;  {&#xD;&#xA;    sessionStore.Remove(wrapped);&#xD;&#xA;    throw;&#xD;&#xA;  }&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;Here's the beginnings of a test case to prevent regression.&#xD;&#xA;&#xD;&#xA;_________________________________________________________________________&#xD;&#xA;&#xD;&#xA;using System;&#xD;&#xA;using System.Collections;&#xD;&#xA;using System.Data;&#xD;&#xA;using System.Data.Common;&#xD;&#xA;using Castle.Facilities.NHibernateIntegration.Internal;&#xD;&#xA;using Castle.MicroKernel;&#xD;&#xA;using Castle.Services.Transaction;&#xD;&#xA;using NHibernate;&#xD;&#xA;using NUnit.Framework;&#xD;&#xA;using Rhino.Mocks;&#xD;&#xA;using ITransaction = Castle.Services.Transaction.ITransaction;&#xD;&#xA;&#xD;&#xA;namespace Castle.Facilities.NHibernateIntegration.Tests&#xD;&#xA;{&#xD;&#xA;    [TestFixture]&#xD;&#xA;    public class DefaultSessionManagerTestCase&#xD;&#xA;    {&#xD;&#xA;        const string Alias = &quot;myAlias&quot;;&#xD;&#xA;        const string InterceptorFormatString = &quot;nhibernate.session.interceptor.{0}&quot;;&#xD;&#xA;        const string InterceptorName = &quot;nhibernate.session.interceptor&quot;;&#xD;&#xA;        const IsolationMode DefaultIsolationMode = IsolationMode.ReadUncommitted;&#xD;&#xA;        const IsolationLevel DefaultIsolationLevel = IsolationLevel.ReadUncommitted;&#xD;&#xA;&#xD;&#xA;        MockRepository mockRepository;&#xD;&#xA;&#xD;&#xA;        ISessionStore sessionStore;&#xD;&#xA;        IKernel kernel;&#xD;&#xA;        ISessionFactoryResolver factoryResolver;&#xD;&#xA;        ITransactionManager transactionManager;&#xD;&#xA;        ITransaction transaction;&#xD;&#xA;        ISessionFactory sessionFactory;&#xD;&#xA;        ISession session;&#xD;&#xA;        IDictionary contextDictionary;&#xD;&#xA;        SessionDelegate savedSessionDelegate;&#xD;&#xA;&#xD;&#xA;        DefaultSessionManager sessionManager;&#xD;&#xA;&#xD;&#xA;        T StrictMock&lt;T&gt;()&#xD;&#xA;        {&#xD;&#xA;            return mockRepository.StrictMock&lt;T&gt;();&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        [SetUp]&#xD;&#xA;        public void SetUp()&#xD;&#xA;        {&#xD;&#xA;            mockRepository = new MockRepository();&#xD;&#xA;&#xD;&#xA;            sessionStore = StrictMock&lt;ISessionStore&gt;();&#xD;&#xA;            kernel = StrictMock&lt;IKernel&gt;();&#xD;&#xA;            factoryResolver = StrictMock&lt;ISessionFactoryResolver&gt;();&#xD;&#xA;            transactionManager = StrictMock&lt;ITransactionManager&gt;();&#xD;&#xA;            transaction = StrictMock&lt;ITransaction&gt;();&#xD;&#xA;            sessionFactory = StrictMock&lt;ISessionFactory&gt;();&#xD;&#xA;            session = StrictMock&lt;ISession&gt;();&#xD;&#xA;            contextDictionary = new Hashtable();&#xD;&#xA;&#xD;&#xA;            sessionManager = new DefaultSessionManager(sessionStore, kernel, factoryResolver);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        static void ExpectReturn(object ignored, object returnValue)&#xD;&#xA;        {&#xD;&#xA;            Expect.Call(ignored).Return(returnValue);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        static void ExpectMissingComponent(IKernel kernel, string component)&#xD;&#xA;        {&#xD;&#xA;            ExpectReturn(kernel.HasComponent(component), false);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        bool SessionStoreStoreCorrect(string alias, SessionDelegate sessionDelegate)&#xD;&#xA;        {&#xD;&#xA;            savedSessionDelegate = sessionDelegate;&#xD;&#xA;            return alias == Alias&#xD;&#xA;                &amp;&amp; sessionDelegate != null&#xD;&#xA;                &amp;&amp; sessionDelegate.InnerSession == session;&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        Exception CreateException()&#xD;&#xA;        {&#xD;&#xA;            return mockRepository.Stub&lt;DbException&gt;(&quot;A transport-level error has occurred when sending the request to the server.&quot;);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        bool SessionStoreRemoveCorrect(SessionDelegate sessionDelegate)&#xD;&#xA;        {&#xD;&#xA;            return ReferenceEquals(savedSessionDelegate, sessionDelegate);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        [Test]&#xD;&#xA;        public void WhenBeginTransactionFailsSessionIsRemovedFromSessionStore()&#xD;&#xA;        {&#xD;&#xA;            using (mockRepository.Record())&#xD;&#xA;            {&#xD;&#xA;                ExpectReturn(kernel[typeof(ITransactionManager)], transactionManager);&#xD;&#xA;                ExpectReturn(transactionManager.CurrentTransaction, transaction);&#xD;&#xA;                ExpectReturn(sessionStore.FindCompatibleSession(Alias), null);&#xD;&#xA;                ExpectReturn(factoryResolver.GetSessionFactory(Alias), sessionFactory);&#xD;&#xA;                ExpectMissingComponent(kernel, string.Format(InterceptorFormatString, Alias));&#xD;&#xA;                ExpectMissingComponent(kernel, InterceptorName);&#xD;&#xA;                ExpectReturn(sessionFactory.OpenSession(), session);&#xD;&#xA;                session.FlushMode = sessionManager.DefaultFlushMode;&#xD;&#xA;                sessionStore.Store(null, null);&#xD;&#xA;                LastCall.Callback(new Delegates.Function&lt;bool, string, SessionDelegate&gt;(SessionStoreStoreCorrect));&#xD;&#xA;                Expect.Call(transaction.Context).Return(contextDictionary).Repeat.Any();&#xD;&#xA;                ExpectReturn(transaction.DistributedTransaction, false);&#xD;&#xA;                ExpectReturn(transaction.IsolationMode, DefaultIsolationMode);&#xD;&#xA;                Expect.Call(session.BeginTransaction(DefaultIsolationLevel)).Throw(CreateException());&#xD;&#xA;&#xD;&#xA;                // if we don't remove the session from the session store now, the next call into this code gets the same broken session&#xD;&#xA;                // back from the session store and all further calls using this session store fail.&#xD;&#xA;&#xD;&#xA;                sessionStore.Remove(null);&#xD;&#xA;                LastCall.Callback(new Delegates.Function&lt;bool, SessionDelegate&gt;(SessionStoreRemoveCorrect));&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            using (mockRepository.Playback())&#xD;&#xA;            {&#xD;&#xA;                try&#xD;&#xA;                {&#xD;&#xA;                    sessionManager.OpenSession(Alias);&#xD;&#xA;                    Assert.Fail(&quot;DbException not thrown&quot;);&#xD;&#xA;                }&#xD;&#xA;                catch (DbException)&#xD;&#xA;                {&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;{quote}&#xD;&#xA;" created="1219935960000" />
    <comment author="aaron.armstrong.sungard" text="* '''Description''' changed from:&#xD;&#xA;{quote}&#xD;&#xA;In the current DefaultSessionManager implementation, if an exception is thrown when a session in enlisted in a transaction, the session is left in the session store. (This may occur when network connectivity to the database [SQL Server] is lost and ISession.BeginTransaction throws an exception.) This transaction fails as it should, but the problem is that all future transactions that use this session store also fail (since the zombie session stays in the session store and future transactions get the zombie session). This is particularly bad when using the TLSActivityManager and the ThreadPool, since now some arbitrary worker thread can no longer process transactions.&#xD;&#xA;&#xD;&#xA;The 99% fix is to catch exceptions coming out of EnlistIfNecessary, remove the session from the session store, and rethrow.&#xD;&#xA;&#xD;&#xA;if (wrapped == null)&#xD;&#xA;{&#xD;&#xA;  session = CreateSession(alias); weAreSessionOwner = true;&#xD;&#xA;&#xD;&#xA;  wrapped = WrapSession(transaction != null, session);&#xD;&#xA;&#xD;&#xA;  sessionStore.Store(alias, wrapped);&#xD;&#xA;&#xD;&#xA;  try&#xD;&#xA;  {&#xD;&#xA;    EnlistIfNecessary(weAreSessionOwner, transaction, wrapped);&#xD;&#xA;  }&#xD;&#xA;  catch&#xD;&#xA;  {&#xD;&#xA;    sessionStore.Remove(wrapped);&#xD;&#xA;    throw;&#xD;&#xA;  }&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;Here's the beginnings of a test case to prevent regression.&#xD;&#xA;&#xD;&#xA;_________________________________________________________________________&#xD;&#xA;&#xD;&#xA;using System;&#xD;&#xA;using System.Collections;&#xD;&#xA;using System.Data;&#xD;&#xA;using System.Data.Common;&#xD;&#xA;using Castle.Facilities.NHibernateIntegration.Internal;&#xD;&#xA;using Castle.MicroKernel;&#xD;&#xA;using Castle.Services.Transaction;&#xD;&#xA;using NHibernate;&#xD;&#xA;using NUnit.Framework;&#xD;&#xA;using Rhino.Mocks;&#xD;&#xA;using ITransaction = Castle.Services.Transaction.ITransaction;&#xD;&#xA;&#xD;&#xA;namespace Castle.Facilities.NHibernateIntegration.Tests&#xD;&#xA;{&#xD;&#xA;    [TestFixture]&#xD;&#xA;    public class DefaultSessionManagerTestCase&#xD;&#xA;    {&#xD;&#xA;        const string Alias = &quot;myAlias&quot;;&#xD;&#xA;        const string InterceptorFormatString = &quot;nhibernate.session.interceptor.{0}&quot;;&#xD;&#xA;        const string InterceptorName = &quot;nhibernate.session.interceptor&quot;;&#xD;&#xA;        const IsolationMode DefaultIsolationMode = IsolationMode.ReadUncommitted;&#xD;&#xA;        const IsolationLevel DefaultIsolationLevel = IsolationLevel.ReadUncommitted;&#xD;&#xA;&#xD;&#xA;        MockRepository mockRepository;&#xD;&#xA;&#xD;&#xA;        ISessionStore sessionStore;&#xD;&#xA;        IKernel kernel;&#xD;&#xA;        ISessionFactoryResolver factoryResolver;&#xD;&#xA;        ITransactionManager transactionManager;&#xD;&#xA;        ITransaction transaction;&#xD;&#xA;        ISessionFactory sessionFactory;&#xD;&#xA;        ISession session;&#xD;&#xA;        IDictionary contextDictionary;&#xD;&#xA;        SessionDelegate savedSessionDelegate;&#xD;&#xA;&#xD;&#xA;        DefaultSessionManager sessionManager;&#xD;&#xA;&#xD;&#xA;        T StrictMock&lt;T&gt;()&#xD;&#xA;        {&#xD;&#xA;            return mockRepository.StrictMock&lt;T&gt;();&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        [SetUp]&#xD;&#xA;        public void SetUp()&#xD;&#xA;        {&#xD;&#xA;            mockRepository = new MockRepository();&#xD;&#xA;&#xD;&#xA;            sessionStore = StrictMock&lt;ISessionStore&gt;();&#xD;&#xA;            kernel = StrictMock&lt;IKernel&gt;();&#xD;&#xA;            factoryResolver = StrictMock&lt;ISessionFactoryResolver&gt;();&#xD;&#xA;            transactionManager = StrictMock&lt;ITransactionManager&gt;();&#xD;&#xA;            transaction = StrictMock&lt;ITransaction&gt;();&#xD;&#xA;            sessionFactory = StrictMock&lt;ISessionFactory&gt;();&#xD;&#xA;            session = StrictMock&lt;ISession&gt;();&#xD;&#xA;            contextDictionary = new Hashtable();&#xD;&#xA;&#xD;&#xA;            sessionManager = new DefaultSessionManager(sessionStore, kernel, factoryResolver);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        static void ExpectReturn(object ignored, object returnValue)&#xD;&#xA;        {&#xD;&#xA;            Expect.Call(ignored).Return(returnValue);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        static void ExpectMissingComponent(IKernel kernel, string component)&#xD;&#xA;        {&#xD;&#xA;            ExpectReturn(kernel.HasComponent(component), false);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        bool SessionStoreStoreCorrect(string alias, SessionDelegate sessionDelegate)&#xD;&#xA;        {&#xD;&#xA;            savedSessionDelegate = sessionDelegate;&#xD;&#xA;            return alias == Alias&#xD;&#xA;                &amp;&amp; sessionDelegate != null&#xD;&#xA;                &amp;&amp; sessionDelegate.InnerSession == session;&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        Exception CreateException()&#xD;&#xA;        {&#xD;&#xA;            return mockRepository.Stub&lt;DbException&gt;(&quot;A transport-level error has occurred when sending the request to the server.&quot;);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        bool SessionStoreRemoveCorrect(SessionDelegate sessionDelegate)&#xD;&#xA;        {&#xD;&#xA;            return ReferenceEquals(savedSessionDelegate, sessionDelegate);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        [Test]&#xD;&#xA;        public void WhenBeginTransactionFailsSessionIsRemovedFromSessionStore()&#xD;&#xA;        {&#xD;&#xA;            using (mockRepository.Record())&#xD;&#xA;            {&#xD;&#xA;                ExpectReturn(kernel[typeof(ITransactionManager)], transactionManager);&#xD;&#xA;                ExpectReturn(transactionManager.CurrentTransaction, transaction);&#xD;&#xA;                ExpectReturn(sessionStore.FindCompatibleSession(Alias), null);&#xD;&#xA;                ExpectReturn(factoryResolver.GetSessionFactory(Alias), sessionFactory);&#xD;&#xA;                ExpectMissingComponent(kernel, string.Format(InterceptorFormatString, Alias));&#xD;&#xA;                ExpectMissingComponent(kernel, InterceptorName);&#xD;&#xA;                ExpectReturn(sessionFactory.OpenSession(), session);&#xD;&#xA;                session.FlushMode = sessionManager.DefaultFlushMode;&#xD;&#xA;                sessionStore.Store(null, null);&#xD;&#xA;                LastCall.Callback(new Delegates.Function&lt;bool, string, SessionDelegate&gt;(SessionStoreStoreCorrect));&#xD;&#xA;                Expect.Call(transaction.Context).Return(contextDictionary).Repeat.Any();&#xD;&#xA;                ExpectReturn(transaction.DistributedTransaction, false);&#xD;&#xA;                ExpectReturn(transaction.IsolationMode, DefaultIsolationMode);&#xD;&#xA;                Expect.Call(session.BeginTransaction(DefaultIsolationLevel)).Throw(CreateException());&#xD;&#xA;&#xD;&#xA;                // if we don't remove the session from the session store now, the next call into this code gets the same broken session&#xD;&#xA;                // back from the session store and all further calls using this session store fail.&#xD;&#xA;&#xD;&#xA;                sessionStore.Remove(null);&#xD;&#xA;                LastCall.Callback(new Delegates.Function&lt;bool, SessionDelegate&gt;(SessionStoreRemoveCorrect));&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            using (mockRepository.Playback())&#xD;&#xA;            {&#xD;&#xA;                try&#xD;&#xA;                {&#xD;&#xA;                    sessionManager.OpenSession(Alias);&#xD;&#xA;                    Assert.Fail(&quot;DbException not thrown&quot;);&#xD;&#xA;                }&#xD;&#xA;                catch (DbException)&#xD;&#xA;                {&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;{quote}&#xD;&#xA;to:&#xD;&#xA;{quote}&#xD;&#xA;In the current DefaultSessionManager implementation, if an exception is thrown when a session in enlisted in a transaction, the session is left in the session store. (This may occur when network connectivity to the database [SQL Server] is lost and ISession.BeginTransaction throws an exception.) This transaction fails as it should, but the problem is that all future transactions that use this session store also fail (since the zombie session stays in the session store and future transactions get the zombie session). This is particularly bad when using the TLSActivityManager and the ThreadPool, since now some arbitrary worker thread can no longer process transactions.&#xD;&#xA;&#xD;&#xA;Probably the right (99%) fix is to swap the order: enlist in transaction and then store the session (does this break anything else?).&#xD;&#xA;&#xD;&#xA;if (wrapped == null)&#xD;&#xA;{&#xD;&#xA;  session = CreateSession(alias); weAreSessionOwner = true;&#xD;&#xA;&#xD;&#xA;  wrapped = WrapSession(transaction != null, session);&#xD;&#xA;&#xD;&#xA;  EnlistIfNecessary(weAreSessionOwner, transaction, wrapped);&#xD;&#xA;&#xD;&#xA;  sessionStore.Store(alias, wrapped);&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;If swapping the order is too risky, the next best fix is to catch exceptions coming out of EnlistIfNecessary, remove the session from the session store, and rethrow.&#xD;&#xA;&#xD;&#xA;if (wrapped == null)&#xD;&#xA;{&#xD;&#xA;  session = CreateSession(alias); weAreSessionOwner = true;&#xD;&#xA;&#xD;&#xA;  wrapped = WrapSession(transaction != null, session);&#xD;&#xA;&#xD;&#xA;  sessionStore.Store(alias, wrapped);&#xD;&#xA;&#xD;&#xA;  try&#xD;&#xA;  {&#xD;&#xA;    EnlistIfNecessary(weAreSessionOwner, transaction, wrapped);&#xD;&#xA;  }&#xD;&#xA;  catch&#xD;&#xA;  {&#xD;&#xA;    sessionStore.Remove(wrapped);&#xD;&#xA;    throw;&#xD;&#xA;  }&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;Here's the beginnings of a test case to prevent regression.&#xD;&#xA;&#xD;&#xA;_________________________________________________________________________&#xD;&#xA;&#xD;&#xA;using System;&#xD;&#xA;using System.Collections;&#xD;&#xA;using System.Data;&#xD;&#xA;using System.Data.Common;&#xD;&#xA;using Castle.Facilities.NHibernateIntegration.Internal;&#xD;&#xA;using Castle.MicroKernel;&#xD;&#xA;using Castle.Services.Transaction;&#xD;&#xA;using NHibernate;&#xD;&#xA;using NUnit.Framework;&#xD;&#xA;using Rhino.Mocks;&#xD;&#xA;using ITransaction = Castle.Services.Transaction.ITransaction;&#xD;&#xA;&#xD;&#xA;namespace Castle.Facilities.NHibernateIntegration.Tests&#xD;&#xA;{&#xD;&#xA;    [TestFixture]&#xD;&#xA;    public class DefaultSessionManagerTestCase&#xD;&#xA;    {&#xD;&#xA;        const string Alias = &quot;myAlias&quot;;&#xD;&#xA;        const string InterceptorFormatString = &quot;nhibernate.session.interceptor.{0}&quot;;&#xD;&#xA;        const string InterceptorName = &quot;nhibernate.session.interceptor&quot;;&#xD;&#xA;        const IsolationMode DefaultIsolationMode = IsolationMode.ReadUncommitted;&#xD;&#xA;        const IsolationLevel DefaultIsolationLevel = IsolationLevel.ReadUncommitted;&#xD;&#xA;&#xD;&#xA;        MockRepository mockRepository;&#xD;&#xA;&#xD;&#xA;        ISessionStore sessionStore;&#xD;&#xA;        IKernel kernel;&#xD;&#xA;        ISessionFactoryResolver factoryResolver;&#xD;&#xA;        ITransactionManager transactionManager;&#xD;&#xA;        ITransaction transaction;&#xD;&#xA;        ISessionFactory sessionFactory;&#xD;&#xA;        ISession session;&#xD;&#xA;        IDictionary contextDictionary;&#xD;&#xA;&#xD;&#xA;        DefaultSessionManager sessionManager;&#xD;&#xA;&#xD;&#xA;        T StrictMock&lt;T&gt;()&#xD;&#xA;        {&#xD;&#xA;            return mockRepository.StrictMock&lt;T&gt;();&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        [SetUp]&#xD;&#xA;        public void SetUp()&#xD;&#xA;        {&#xD;&#xA;            mockRepository = new MockRepository();&#xD;&#xA;&#xD;&#xA;            sessionStore = StrictMock&lt;ISessionStore&gt;();&#xD;&#xA;            kernel = StrictMock&lt;IKernel&gt;();&#xD;&#xA;            factoryResolver = StrictMock&lt;ISessionFactoryResolver&gt;();&#xD;&#xA;            transactionManager = StrictMock&lt;ITransactionManager&gt;();&#xD;&#xA;            transaction = StrictMock&lt;ITransaction&gt;();&#xD;&#xA;            sessionFactory = StrictMock&lt;ISessionFactory&gt;();&#xD;&#xA;            session = StrictMock&lt;ISession&gt;();&#xD;&#xA;            contextDictionary = new Hashtable();&#xD;&#xA;&#xD;&#xA;            sessionManager = new DefaultSessionManager(sessionStore, kernel, factoryResolver);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        static void ExpectReturn(object ignored, object returnValue)&#xD;&#xA;        {&#xD;&#xA;            Expect.Call(ignored).Return(returnValue);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        static void ExpectMissingComponent(IKernel kernel, string component)&#xD;&#xA;        {&#xD;&#xA;            ExpectReturn(kernel.HasComponent(component), false);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        Exception CreateException()&#xD;&#xA;        {&#xD;&#xA;            return mockRepository.Stub&lt;DbException&gt;(&quot;A transport-level error has occurred when sending the request to the server.&quot;);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        [Test]&#xD;&#xA;        public void WhenBeginTransactionFailsSessionIsRemovedFromSessionStore()&#xD;&#xA;        {&#xD;&#xA;            using (mockRepository.Record())&#xD;&#xA;            {&#xD;&#xA;                ExpectReturn(kernel[typeof(ITransactionManager)], transactionManager);&#xD;&#xA;                ExpectReturn(transactionManager.CurrentTransaction, transaction);&#xD;&#xA;                ExpectReturn(sessionStore.FindCompatibleSession(Alias), null);&#xD;&#xA;                ExpectReturn(factoryResolver.GetSessionFactory(Alias), sessionFactory);&#xD;&#xA;                ExpectMissingComponent(kernel, string.Format(InterceptorFormatString, Alias));&#xD;&#xA;                ExpectMissingComponent(kernel, InterceptorName);&#xD;&#xA;                ExpectReturn(sessionFactory.OpenSession(), session);&#xD;&#xA;                session.FlushMode = sessionManager.DefaultFlushMode;&#xD;&#xA;                Expect.Call(transaction.Context).Return(contextDictionary).Repeat.Any();&#xD;&#xA;                ExpectReturn(transaction.DistributedTransaction, false);&#xD;&#xA;                ExpectReturn(transaction.IsolationMode, DefaultIsolationMode);&#xD;&#xA;                Expect.Call(session.BeginTransaction(DefaultIsolationLevel)).Throw(CreateException());&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            using (mockRepository.Playback())&#xD;&#xA;            {&#xD;&#xA;                try&#xD;&#xA;                {&#xD;&#xA;                    sessionManager.OpenSession(Alias);&#xD;&#xA;                    Assert.Fail(&quot;DbException not thrown&quot;);&#xD;&#xA;                }&#xD;&#xA;                catch (DbException)&#xD;&#xA;                {&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;{quote}&#xD;&#xA;" created="1219991880000" />
    <comment author="aaron.armstrong.sungard" text="* '''Description''' changed from:&#xD;&#xA;{quote}&#xD;&#xA;In the current DefaultSessionManager implementation, if an exception is thrown when a session in enlisted in a transaction, the session is left in the session store. (This may occur when network connectivity to the database [SQL Server] is lost and ISession.BeginTransaction throws an exception.) This transaction fails as it should, but the problem is that all future transactions that use this session store also fail (since the zombie session stays in the session store and future transactions get the zombie session). This is particularly bad when using the TLSActivityManager and the ThreadPool, since now some arbitrary worker thread can no longer process transactions.&#xD;&#xA;&#xD;&#xA;Probably the right (99%) fix is to swap the order: enlist in transaction and then store the session (does this break anything else?).&#xD;&#xA;&#xD;&#xA;if (wrapped == null)&#xD;&#xA;{&#xD;&#xA;  session = CreateSession(alias); weAreSessionOwner = true;&#xD;&#xA;&#xD;&#xA;  wrapped = WrapSession(transaction != null, session);&#xD;&#xA;&#xD;&#xA;  EnlistIfNecessary(weAreSessionOwner, transaction, wrapped);&#xD;&#xA;&#xD;&#xA;  sessionStore.Store(alias, wrapped);&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;If swapping the order is too risky, the next best fix is to catch exceptions coming out of EnlistIfNecessary, remove the session from the session store, and rethrow.&#xD;&#xA;&#xD;&#xA;if (wrapped == null)&#xD;&#xA;{&#xD;&#xA;  session = CreateSession(alias); weAreSessionOwner = true;&#xD;&#xA;&#xD;&#xA;  wrapped = WrapSession(transaction != null, session);&#xD;&#xA;&#xD;&#xA;  sessionStore.Store(alias, wrapped);&#xD;&#xA;&#xD;&#xA;  try&#xD;&#xA;  {&#xD;&#xA;    EnlistIfNecessary(weAreSessionOwner, transaction, wrapped);&#xD;&#xA;  }&#xD;&#xA;  catch&#xD;&#xA;  {&#xD;&#xA;    sessionStore.Remove(wrapped);&#xD;&#xA;    throw;&#xD;&#xA;  }&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;Here's the beginnings of a test case to prevent regression.&#xD;&#xA;&#xD;&#xA;_________________________________________________________________________&#xD;&#xA;&#xD;&#xA;using System;&#xD;&#xA;using System.Collections;&#xD;&#xA;using System.Data;&#xD;&#xA;using System.Data.Common;&#xD;&#xA;using Castle.Facilities.NHibernateIntegration.Internal;&#xD;&#xA;using Castle.MicroKernel;&#xD;&#xA;using Castle.Services.Transaction;&#xD;&#xA;using NHibernate;&#xD;&#xA;using NUnit.Framework;&#xD;&#xA;using Rhino.Mocks;&#xD;&#xA;using ITransaction = Castle.Services.Transaction.ITransaction;&#xD;&#xA;&#xD;&#xA;namespace Castle.Facilities.NHibernateIntegration.Tests&#xD;&#xA;{&#xD;&#xA;    [TestFixture]&#xD;&#xA;    public class DefaultSessionManagerTestCase&#xD;&#xA;    {&#xD;&#xA;        const string Alias = &quot;myAlias&quot;;&#xD;&#xA;        const string InterceptorFormatString = &quot;nhibernate.session.interceptor.{0}&quot;;&#xD;&#xA;        const string InterceptorName = &quot;nhibernate.session.interceptor&quot;;&#xD;&#xA;        const IsolationMode DefaultIsolationMode = IsolationMode.ReadUncommitted;&#xD;&#xA;        const IsolationLevel DefaultIsolationLevel = IsolationLevel.ReadUncommitted;&#xD;&#xA;&#xD;&#xA;        MockRepository mockRepository;&#xD;&#xA;&#xD;&#xA;        ISessionStore sessionStore;&#xD;&#xA;        IKernel kernel;&#xD;&#xA;        ISessionFactoryResolver factoryResolver;&#xD;&#xA;        ITransactionManager transactionManager;&#xD;&#xA;        ITransaction transaction;&#xD;&#xA;        ISessionFactory sessionFactory;&#xD;&#xA;        ISession session;&#xD;&#xA;        IDictionary contextDictionary;&#xD;&#xA;&#xD;&#xA;        DefaultSessionManager sessionManager;&#xD;&#xA;&#xD;&#xA;        T StrictMock&lt;T&gt;()&#xD;&#xA;        {&#xD;&#xA;            return mockRepository.StrictMock&lt;T&gt;();&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        [SetUp]&#xD;&#xA;        public void SetUp()&#xD;&#xA;        {&#xD;&#xA;            mockRepository = new MockRepository();&#xD;&#xA;&#xD;&#xA;            sessionStore = StrictMock&lt;ISessionStore&gt;();&#xD;&#xA;            kernel = StrictMock&lt;IKernel&gt;();&#xD;&#xA;            factoryResolver = StrictMock&lt;ISessionFactoryResolver&gt;();&#xD;&#xA;            transactionManager = StrictMock&lt;ITransactionManager&gt;();&#xD;&#xA;            transaction = StrictMock&lt;ITransaction&gt;();&#xD;&#xA;            sessionFactory = StrictMock&lt;ISessionFactory&gt;();&#xD;&#xA;            session = StrictMock&lt;ISession&gt;();&#xD;&#xA;            contextDictionary = new Hashtable();&#xD;&#xA;&#xD;&#xA;            sessionManager = new DefaultSessionManager(sessionStore, kernel, factoryResolver);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        static void ExpectReturn(object ignored, object returnValue)&#xD;&#xA;        {&#xD;&#xA;            Expect.Call(ignored).Return(returnValue);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        static void ExpectMissingComponent(IKernel kernel, string component)&#xD;&#xA;        {&#xD;&#xA;            ExpectReturn(kernel.HasComponent(component), false);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        Exception CreateException()&#xD;&#xA;        {&#xD;&#xA;            return mockRepository.Stub&lt;DbException&gt;(&quot;A transport-level error has occurred when sending the request to the server.&quot;);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        [Test]&#xD;&#xA;        public void WhenBeginTransactionFailsSessionIsRemovedFromSessionStore()&#xD;&#xA;        {&#xD;&#xA;            using (mockRepository.Record())&#xD;&#xA;            {&#xD;&#xA;                ExpectReturn(kernel[typeof(ITransactionManager)], transactionManager);&#xD;&#xA;                ExpectReturn(transactionManager.CurrentTransaction, transaction);&#xD;&#xA;                ExpectReturn(sessionStore.FindCompatibleSession(Alias), null);&#xD;&#xA;                ExpectReturn(factoryResolver.GetSessionFactory(Alias), sessionFactory);&#xD;&#xA;                ExpectMissingComponent(kernel, string.Format(InterceptorFormatString, Alias));&#xD;&#xA;                ExpectMissingComponent(kernel, InterceptorName);&#xD;&#xA;                ExpectReturn(sessionFactory.OpenSession(), session);&#xD;&#xA;                session.FlushMode = sessionManager.DefaultFlushMode;&#xD;&#xA;                Expect.Call(transaction.Context).Return(contextDictionary).Repeat.Any();&#xD;&#xA;                ExpectReturn(transaction.DistributedTransaction, false);&#xD;&#xA;                ExpectReturn(transaction.IsolationMode, DefaultIsolationMode);&#xD;&#xA;                Expect.Call(session.BeginTransaction(DefaultIsolationLevel)).Throw(CreateException());&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            using (mockRepository.Playback())&#xD;&#xA;            {&#xD;&#xA;                try&#xD;&#xA;                {&#xD;&#xA;                    sessionManager.OpenSession(Alias);&#xD;&#xA;                    Assert.Fail(&quot;DbException not thrown&quot;);&#xD;&#xA;                }&#xD;&#xA;                catch (DbException)&#xD;&#xA;                {&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;{quote}&#xD;&#xA;to:&#xD;&#xA;{quote}&#xD;&#xA;In the current DefaultSessionManager implementation, if an exception is thrown when a session in enlisted in a transaction, the session is left in the session store. (This may occur when network connectivity to the database [SQL Server] is lost and ISession.BeginTransaction throws an exception.) This transaction fails as it should, but the problem is that all future transactions that use this session store also fail (since the zombie session stays in the session store and future transactions get the zombie session). This is particularly bad when using the TLSActivityManager and the ThreadPool, since now some arbitrary worker thread can no longer process transactions.&#xD;&#xA;&#xD;&#xA;Probably the right (99%) fix is to swap the order: enlist in transaction and then store the session (does this break anything else?).&#xD;&#xA;&#xD;&#xA;&lt;code&gt;&#xD;&#xA;if (wrapped == null)&#xD;&#xA;{&#xD;&#xA;  session = CreateSession(alias); weAreSessionOwner = true;&#xD;&#xA;&#xD;&#xA;  wrapped = WrapSession(transaction != null, session);&#xD;&#xA;&#xD;&#xA;  EnlistIfNecessary(weAreSessionOwner, transaction, wrapped);&#xD;&#xA;&#xD;&#xA;  sessionStore.Store(alias, wrapped);&#xD;&#xA;}&#xD;&#xA;&lt;/code&gt;&#xD;&#xA;&#xD;&#xA;If swapping the order is too risky, the next best fix is to catch exceptions coming out of EnlistIfNecessary, remove the session from the session store, and rethrow.&#xD;&#xA;&#xD;&#xA;if (wrapped == null)&#xD;&#xA;{&#xD;&#xA;  session = CreateSession(alias); weAreSessionOwner = true;&#xD;&#xA;&#xD;&#xA;  wrapped = WrapSession(transaction != null, session);&#xD;&#xA;&#xD;&#xA;  sessionStore.Store(alias, wrapped);&#xD;&#xA;&#xD;&#xA;  try&#xD;&#xA;  {&#xD;&#xA;    EnlistIfNecessary(weAreSessionOwner, transaction, wrapped);&#xD;&#xA;  }&#xD;&#xA;  catch&#xD;&#xA;  {&#xD;&#xA;    sessionStore.Remove(wrapped);&#xD;&#xA;    throw;&#xD;&#xA;  }&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;Here's the beginnings of a test case to prevent regression.&#xD;&#xA;&#xD;&#xA;_________________________________________________________________________&#xD;&#xA;&#xD;&#xA;using System;&#xD;&#xA;using System.Collections;&#xD;&#xA;using System.Data;&#xD;&#xA;using System.Data.Common;&#xD;&#xA;using Castle.Facilities.NHibernateIntegration.Internal;&#xD;&#xA;using Castle.MicroKernel;&#xD;&#xA;using Castle.Services.Transaction;&#xD;&#xA;using NHibernate;&#xD;&#xA;using NUnit.Framework;&#xD;&#xA;using Rhino.Mocks;&#xD;&#xA;using ITransaction = Castle.Services.Transaction.ITransaction;&#xD;&#xA;&#xD;&#xA;namespace Castle.Facilities.NHibernateIntegration.Tests&#xD;&#xA;{&#xD;&#xA;    [TestFixture]&#xD;&#xA;    public class DefaultSessionManagerTestCase&#xD;&#xA;    {&#xD;&#xA;        const string Alias = &quot;myAlias&quot;;&#xD;&#xA;        const string InterceptorFormatString = &quot;nhibernate.session.interceptor.{0}&quot;;&#xD;&#xA;        const string InterceptorName = &quot;nhibernate.session.interceptor&quot;;&#xD;&#xA;        const IsolationMode DefaultIsolationMode = IsolationMode.ReadUncommitted;&#xD;&#xA;        const IsolationLevel DefaultIsolationLevel = IsolationLevel.ReadUncommitted;&#xD;&#xA;&#xD;&#xA;        MockRepository mockRepository;&#xD;&#xA;&#xD;&#xA;        ISessionStore sessionStore;&#xD;&#xA;        IKernel kernel;&#xD;&#xA;        ISessionFactoryResolver factoryResolver;&#xD;&#xA;        ITransactionManager transactionManager;&#xD;&#xA;        ITransaction transaction;&#xD;&#xA;        ISessionFactory sessionFactory;&#xD;&#xA;        ISession session;&#xD;&#xA;        IDictionary contextDictionary;&#xD;&#xA;&#xD;&#xA;        DefaultSessionManager sessionManager;&#xD;&#xA;&#xD;&#xA;        T StrictMock&lt;T&gt;()&#xD;&#xA;        {&#xD;&#xA;            return mockRepository.StrictMock&lt;T&gt;();&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        [SetUp]&#xD;&#xA;        public void SetUp()&#xD;&#xA;        {&#xD;&#xA;            mockRepository = new MockRepository();&#xD;&#xA;&#xD;&#xA;            sessionStore = StrictMock&lt;ISessionStore&gt;();&#xD;&#xA;            kernel = StrictMock&lt;IKernel&gt;();&#xD;&#xA;            factoryResolver = StrictMock&lt;ISessionFactoryResolver&gt;();&#xD;&#xA;            transactionManager = StrictMock&lt;ITransactionManager&gt;();&#xD;&#xA;            transaction = StrictMock&lt;ITransaction&gt;();&#xD;&#xA;            sessionFactory = StrictMock&lt;ISessionFactory&gt;();&#xD;&#xA;            session = StrictMock&lt;ISession&gt;();&#xD;&#xA;            contextDictionary = new Hashtable();&#xD;&#xA;&#xD;&#xA;            sessionManager = new DefaultSessionManager(sessionStore, kernel, factoryResolver);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        static void ExpectReturn(object ignored, object returnValue)&#xD;&#xA;        {&#xD;&#xA;            Expect.Call(ignored).Return(returnValue);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        static void ExpectMissingComponent(IKernel kernel, string component)&#xD;&#xA;        {&#xD;&#xA;            ExpectReturn(kernel.HasComponent(component), false);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        Exception CreateException()&#xD;&#xA;        {&#xD;&#xA;            return mockRepository.Stub&lt;DbException&gt;(&quot;A transport-level error has occurred when sending the request to the server.&quot;);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        [Test]&#xD;&#xA;        public void WhenBeginTransactionFailsSessionIsRemovedFromSessionStore()&#xD;&#xA;        {&#xD;&#xA;            using (mockRepository.Record())&#xD;&#xA;            {&#xD;&#xA;                ExpectReturn(kernel[typeof(ITransactionManager)], transactionManager);&#xD;&#xA;                ExpectReturn(transactionManager.CurrentTransaction, transaction);&#xD;&#xA;                ExpectReturn(sessionStore.FindCompatibleSession(Alias), null);&#xD;&#xA;                ExpectReturn(factoryResolver.GetSessionFactory(Alias), sessionFactory);&#xD;&#xA;                ExpectMissingComponent(kernel, string.Format(InterceptorFormatString, Alias));&#xD;&#xA;                ExpectMissingComponent(kernel, InterceptorName);&#xD;&#xA;                ExpectReturn(sessionFactory.OpenSession(), session);&#xD;&#xA;                session.FlushMode = sessionManager.DefaultFlushMode;&#xD;&#xA;                Expect.Call(transaction.Context).Return(contextDictionary).Repeat.Any();&#xD;&#xA;                ExpectReturn(transaction.DistributedTransaction, false);&#xD;&#xA;                ExpectReturn(transaction.IsolationMode, DefaultIsolationMode);&#xD;&#xA;                Expect.Call(session.BeginTransaction(DefaultIsolationLevel)).Throw(CreateException());&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            using (mockRepository.Playback())&#xD;&#xA;            {&#xD;&#xA;                try&#xD;&#xA;                {&#xD;&#xA;                    sessionManager.OpenSession(Alias);&#xD;&#xA;                    Assert.Fail(&quot;DbException not thrown&quot;);&#xD;&#xA;                }&#xD;&#xA;                catch (DbException)&#xD;&#xA;                {&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;{quote}&#xD;&#xA;" created="1219991880000" />
    <comment author="aaron.armstrong.sungard" text="* '''Description''' changed from:&#xD;&#xA;{quote}&#xD;&#xA;In the current DefaultSessionManager implementation, if an exception is thrown when a session in enlisted in a transaction, the session is left in the session store. (This may occur when network connectivity to the database [SQL Server] is lost and ISession.BeginTransaction throws an exception.) This transaction fails as it should, but the problem is that all future transactions that use this session store also fail (since the zombie session stays in the session store and future transactions get the zombie session). This is particularly bad when using the TLSActivityManager and the ThreadPool, since now some arbitrary worker thread can no longer process transactions.&#xD;&#xA;&#xD;&#xA;Probably the right (99%) fix is to swap the order: enlist in transaction and then store the session (does this break anything else?).&#xD;&#xA;&#xD;&#xA;&lt;code&gt;&#xD;&#xA;if (wrapped == null)&#xD;&#xA;{&#xD;&#xA;  session = CreateSession(alias); weAreSessionOwner = true;&#xD;&#xA;&#xD;&#xA;  wrapped = WrapSession(transaction != null, session);&#xD;&#xA;&#xD;&#xA;  EnlistIfNecessary(weAreSessionOwner, transaction, wrapped);&#xD;&#xA;&#xD;&#xA;  sessionStore.Store(alias, wrapped);&#xD;&#xA;}&#xD;&#xA;&lt;/code&gt;&#xD;&#xA;&#xD;&#xA;If swapping the order is too risky, the next best fix is to catch exceptions coming out of EnlistIfNecessary, remove the session from the session store, and rethrow.&#xD;&#xA;&#xD;&#xA;if (wrapped == null)&#xD;&#xA;{&#xD;&#xA;  session = CreateSession(alias); weAreSessionOwner = true;&#xD;&#xA;&#xD;&#xA;  wrapped = WrapSession(transaction != null, session);&#xD;&#xA;&#xD;&#xA;  sessionStore.Store(alias, wrapped);&#xD;&#xA;&#xD;&#xA;  try&#xD;&#xA;  {&#xD;&#xA;    EnlistIfNecessary(weAreSessionOwner, transaction, wrapped);&#xD;&#xA;  }&#xD;&#xA;  catch&#xD;&#xA;  {&#xD;&#xA;    sessionStore.Remove(wrapped);&#xD;&#xA;    throw;&#xD;&#xA;  }&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;Here's the beginnings of a test case to prevent regression.&#xD;&#xA;&#xD;&#xA;_________________________________________________________________________&#xD;&#xA;&#xD;&#xA;using System;&#xD;&#xA;using System.Collections;&#xD;&#xA;using System.Data;&#xD;&#xA;using System.Data.Common;&#xD;&#xA;using Castle.Facilities.NHibernateIntegration.Internal;&#xD;&#xA;using Castle.MicroKernel;&#xD;&#xA;using Castle.Services.Transaction;&#xD;&#xA;using NHibernate;&#xD;&#xA;using NUnit.Framework;&#xD;&#xA;using Rhino.Mocks;&#xD;&#xA;using ITransaction = Castle.Services.Transaction.ITransaction;&#xD;&#xA;&#xD;&#xA;namespace Castle.Facilities.NHibernateIntegration.Tests&#xD;&#xA;{&#xD;&#xA;    [TestFixture]&#xD;&#xA;    public class DefaultSessionManagerTestCase&#xD;&#xA;    {&#xD;&#xA;        const string Alias = &quot;myAlias&quot;;&#xD;&#xA;        const string InterceptorFormatString = &quot;nhibernate.session.interceptor.{0}&quot;;&#xD;&#xA;        const string InterceptorName = &quot;nhibernate.session.interceptor&quot;;&#xD;&#xA;        const IsolationMode DefaultIsolationMode = IsolationMode.ReadUncommitted;&#xD;&#xA;        const IsolationLevel DefaultIsolationLevel = IsolationLevel.ReadUncommitted;&#xD;&#xA;&#xD;&#xA;        MockRepository mockRepository;&#xD;&#xA;&#xD;&#xA;        ISessionStore sessionStore;&#xD;&#xA;        IKernel kernel;&#xD;&#xA;        ISessionFactoryResolver factoryResolver;&#xD;&#xA;        ITransactionManager transactionManager;&#xD;&#xA;        ITransaction transaction;&#xD;&#xA;        ISessionFactory sessionFactory;&#xD;&#xA;        ISession session;&#xD;&#xA;        IDictionary contextDictionary;&#xD;&#xA;&#xD;&#xA;        DefaultSessionManager sessionManager;&#xD;&#xA;&#xD;&#xA;        T StrictMock&lt;T&gt;()&#xD;&#xA;        {&#xD;&#xA;            return mockRepository.StrictMock&lt;T&gt;();&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        [SetUp]&#xD;&#xA;        public void SetUp()&#xD;&#xA;        {&#xD;&#xA;            mockRepository = new MockRepository();&#xD;&#xA;&#xD;&#xA;            sessionStore = StrictMock&lt;ISessionStore&gt;();&#xD;&#xA;            kernel = StrictMock&lt;IKernel&gt;();&#xD;&#xA;            factoryResolver = StrictMock&lt;ISessionFactoryResolver&gt;();&#xD;&#xA;            transactionManager = StrictMock&lt;ITransactionManager&gt;();&#xD;&#xA;            transaction = StrictMock&lt;ITransaction&gt;();&#xD;&#xA;            sessionFactory = StrictMock&lt;ISessionFactory&gt;();&#xD;&#xA;            session = StrictMock&lt;ISession&gt;();&#xD;&#xA;            contextDictionary = new Hashtable();&#xD;&#xA;&#xD;&#xA;            sessionManager = new DefaultSessionManager(sessionStore, kernel, factoryResolver);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        static void ExpectReturn(object ignored, object returnValue)&#xD;&#xA;        {&#xD;&#xA;            Expect.Call(ignored).Return(returnValue);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        static void ExpectMissingComponent(IKernel kernel, string component)&#xD;&#xA;        {&#xD;&#xA;            ExpectReturn(kernel.HasComponent(component), false);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        Exception CreateException()&#xD;&#xA;        {&#xD;&#xA;            return mockRepository.Stub&lt;DbException&gt;(&quot;A transport-level error has occurred when sending the request to the server.&quot;);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        [Test]&#xD;&#xA;        public void WhenBeginTransactionFailsSessionIsRemovedFromSessionStore()&#xD;&#xA;        {&#xD;&#xA;            using (mockRepository.Record())&#xD;&#xA;            {&#xD;&#xA;                ExpectReturn(kernel[typeof(ITransactionManager)], transactionManager);&#xD;&#xA;                ExpectReturn(transactionManager.CurrentTransaction, transaction);&#xD;&#xA;                ExpectReturn(sessionStore.FindCompatibleSession(Alias), null);&#xD;&#xA;                ExpectReturn(factoryResolver.GetSessionFactory(Alias), sessionFactory);&#xD;&#xA;                ExpectMissingComponent(kernel, string.Format(InterceptorFormatString, Alias));&#xD;&#xA;                ExpectMissingComponent(kernel, InterceptorName);&#xD;&#xA;                ExpectReturn(sessionFactory.OpenSession(), session);&#xD;&#xA;                session.FlushMode = sessionManager.DefaultFlushMode;&#xD;&#xA;                Expect.Call(transaction.Context).Return(contextDictionary).Repeat.Any();&#xD;&#xA;                ExpectReturn(transaction.DistributedTransaction, false);&#xD;&#xA;                ExpectReturn(transaction.IsolationMode, DefaultIsolationMode);&#xD;&#xA;                Expect.Call(session.BeginTransaction(DefaultIsolationLevel)).Throw(CreateException());&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            using (mockRepository.Playback())&#xD;&#xA;            {&#xD;&#xA;                try&#xD;&#xA;                {&#xD;&#xA;                    sessionManager.OpenSession(Alias);&#xD;&#xA;                    Assert.Fail(&quot;DbException not thrown&quot;);&#xD;&#xA;                }&#xD;&#xA;                catch (DbException)&#xD;&#xA;                {&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;{quote}&#xD;&#xA;to:&#xD;&#xA;{quote}&#xD;&#xA;In the current DefaultSessionManager implementation, if an exception is thrown when a session in enlisted in a transaction, the session is left in the session store. (This may occur when network connectivity to the database [SQL Server] is lost and ISession.BeginTransaction throws an exception.) This transaction fails as it should, but the problem is that all future transactions that use this session store also fail (since the zombie session stays in the session store and future transactions get the zombie session). This is particularly bad when using the TLSActivityManager and the ThreadPool, since now some arbitrary worker thread can no longer process transactions.&#xD;&#xA;&#xD;&#xA;Probably the right (99%) fix is to swap the order: enlist in transaction and then store the session (does this break anything else?).&#xD;&#xA;&#xD;&#xA;if (wrapped == null)&#xD;&#xA;{&#xD;&#xA;  session = CreateSession(alias); weAreSessionOwner = true;&#xD;&#xA;&#xD;&#xA;  wrapped = WrapSession(transaction != null, session);&#xD;&#xA;&#xD;&#xA;  EnlistIfNecessary(weAreSessionOwner, transaction, wrapped);&#xD;&#xA;&#xD;&#xA;  sessionStore.Store(alias, wrapped);&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;If swapping the order is too risky, the next best fix is to catch exceptions coming out of EnlistIfNecessary, remove the session from the session store, and rethrow.&#xD;&#xA;&#xD;&#xA;if (wrapped == null)&#xD;&#xA;{&#xD;&#xA;  session = CreateSession(alias); weAreSessionOwner = true;&#xD;&#xA;&#xD;&#xA;  wrapped = WrapSession(transaction != null, session);&#xD;&#xA;&#xD;&#xA;  sessionStore.Store(alias, wrapped);&#xD;&#xA;&#xD;&#xA;  try&#xD;&#xA;  {&#xD;&#xA;    EnlistIfNecessary(weAreSessionOwner, transaction, wrapped);&#xD;&#xA;  }&#xD;&#xA;  catch&#xD;&#xA;  {&#xD;&#xA;    sessionStore.Remove(wrapped);&#xD;&#xA;    throw;&#xD;&#xA;  }&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;Here's the beginnings of a test case to prevent regression.&#xD;&#xA;&#xD;&#xA;_________________________________________________________________________&#xD;&#xA;&#xD;&#xA;using System;&#xD;&#xA;using System.Collections;&#xD;&#xA;using System.Data;&#xD;&#xA;using System.Data.Common;&#xD;&#xA;using Castle.Facilities.NHibernateIntegration.Internal;&#xD;&#xA;using Castle.MicroKernel;&#xD;&#xA;using Castle.Services.Transaction;&#xD;&#xA;using NHibernate;&#xD;&#xA;using NUnit.Framework;&#xD;&#xA;using Rhino.Mocks;&#xD;&#xA;using ITransaction = Castle.Services.Transaction.ITransaction;&#xD;&#xA;&#xD;&#xA;namespace Castle.Facilities.NHibernateIntegration.Tests&#xD;&#xA;{&#xD;&#xA;    [TestFixture]&#xD;&#xA;    public class DefaultSessionManagerTestCase&#xD;&#xA;    {&#xD;&#xA;        const string Alias = &quot;myAlias&quot;;&#xD;&#xA;        const string InterceptorFormatString = &quot;nhibernate.session.interceptor.{0}&quot;;&#xD;&#xA;        const string InterceptorName = &quot;nhibernate.session.interceptor&quot;;&#xD;&#xA;        const IsolationMode DefaultIsolationMode = IsolationMode.ReadUncommitted;&#xD;&#xA;        const IsolationLevel DefaultIsolationLevel = IsolationLevel.ReadUncommitted;&#xD;&#xA;&#xD;&#xA;        MockRepository mockRepository;&#xD;&#xA;&#xD;&#xA;        ISessionStore sessionStore;&#xD;&#xA;        IKernel kernel;&#xD;&#xA;        ISessionFactoryResolver factoryResolver;&#xD;&#xA;        ITransactionManager transactionManager;&#xD;&#xA;        ITransaction transaction;&#xD;&#xA;        ISessionFactory sessionFactory;&#xD;&#xA;        ISession session;&#xD;&#xA;        IDictionary contextDictionary;&#xD;&#xA;&#xD;&#xA;        DefaultSessionManager sessionManager;&#xD;&#xA;&#xD;&#xA;        T StrictMock&lt;T&gt;()&#xD;&#xA;        {&#xD;&#xA;            return mockRepository.StrictMock&lt;T&gt;();&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        [SetUp]&#xD;&#xA;        public void SetUp()&#xD;&#xA;        {&#xD;&#xA;            mockRepository = new MockRepository();&#xD;&#xA;&#xD;&#xA;            sessionStore = StrictMock&lt;ISessionStore&gt;();&#xD;&#xA;            kernel = StrictMock&lt;IKernel&gt;();&#xD;&#xA;            factoryResolver = StrictMock&lt;ISessionFactoryResolver&gt;();&#xD;&#xA;            transactionManager = StrictMock&lt;ITransactionManager&gt;();&#xD;&#xA;            transaction = StrictMock&lt;ITransaction&gt;();&#xD;&#xA;            sessionFactory = StrictMock&lt;ISessionFactory&gt;();&#xD;&#xA;            session = StrictMock&lt;ISession&gt;();&#xD;&#xA;            contextDictionary = new Hashtable();&#xD;&#xA;&#xD;&#xA;            sessionManager = new DefaultSessionManager(sessionStore, kernel, factoryResolver);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        static void ExpectReturn(object ignored, object returnValue)&#xD;&#xA;        {&#xD;&#xA;            Expect.Call(ignored).Return(returnValue);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        static void ExpectMissingComponent(IKernel kernel, string component)&#xD;&#xA;        {&#xD;&#xA;            ExpectReturn(kernel.HasComponent(component), false);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        Exception CreateException()&#xD;&#xA;        {&#xD;&#xA;            return mockRepository.Stub&lt;DbException&gt;(&quot;A transport-level error has occurred when sending the request to the server.&quot;);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        [Test]&#xD;&#xA;        public void WhenBeginTransactionFailsSessionIsRemovedFromSessionStore()&#xD;&#xA;        {&#xD;&#xA;            using (mockRepository.Record())&#xD;&#xA;            {&#xD;&#xA;                ExpectReturn(kernel[typeof(ITransactionManager)], transactionManager);&#xD;&#xA;                ExpectReturn(transactionManager.CurrentTransaction, transaction);&#xD;&#xA;                ExpectReturn(sessionStore.FindCompatibleSession(Alias), null);&#xD;&#xA;                ExpectReturn(factoryResolver.GetSessionFactory(Alias), sessionFactory);&#xD;&#xA;                ExpectMissingComponent(kernel, string.Format(InterceptorFormatString, Alias));&#xD;&#xA;                ExpectMissingComponent(kernel, InterceptorName);&#xD;&#xA;                ExpectReturn(sessionFactory.OpenSession(), session);&#xD;&#xA;                session.FlushMode = sessionManager.DefaultFlushMode;&#xD;&#xA;                Expect.Call(transaction.Context).Return(contextDictionary).Repeat.Any();&#xD;&#xA;                ExpectReturn(transaction.DistributedTransaction, false);&#xD;&#xA;                ExpectReturn(transaction.IsolationMode, DefaultIsolationMode);&#xD;&#xA;                Expect.Call(session.BeginTransaction(DefaultIsolationLevel)).Throw(CreateException());&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            using (mockRepository.Playback())&#xD;&#xA;            {&#xD;&#xA;                try&#xD;&#xA;                {&#xD;&#xA;                    sessionManager.OpenSession(Alias);&#xD;&#xA;                    Assert.Fail(&quot;DbException not thrown&quot;);&#xD;&#xA;                }&#xD;&#xA;                catch (DbException)&#xD;&#xA;                {&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;{quote}&#xD;&#xA;" created="1219991940000" />
    <comment author="aaron.armstrong.sungard" text="* '''Description''' changed from:&#xD;&#xA;{quote}&#xD;&#xA;In the current DefaultSessionManager implementation, if an exception is thrown when a session in enlisted in a transaction, the session is left in the session store. (This may occur when network connectivity to the database [SQL Server] is lost and ISession.BeginTransaction throws an exception.) This transaction fails as it should, but the problem is that all future transactions that use this session store also fail (since the zombie session stays in the session store and future transactions get the zombie session). This is particularly bad when using the TLSActivityManager and the ThreadPool, since now some arbitrary worker thread can no longer process transactions.&#xD;&#xA;&#xD;&#xA;Probably the right (99%) fix is to swap the order: enlist in transaction and then store the session (does this break anything else?).&#xD;&#xA;&#xD;&#xA;if (wrapped == null)&#xD;&#xA;{&#xD;&#xA;  session = CreateSession(alias); weAreSessionOwner = true;&#xD;&#xA;&#xD;&#xA;  wrapped = WrapSession(transaction != null, session);&#xD;&#xA;&#xD;&#xA;  EnlistIfNecessary(weAreSessionOwner, transaction, wrapped);&#xD;&#xA;&#xD;&#xA;  sessionStore.Store(alias, wrapped);&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;If swapping the order is too risky, the next best fix is to catch exceptions coming out of EnlistIfNecessary, remove the session from the session store, and rethrow.&#xD;&#xA;&#xD;&#xA;if (wrapped == null)&#xD;&#xA;{&#xD;&#xA;  session = CreateSession(alias); weAreSessionOwner = true;&#xD;&#xA;&#xD;&#xA;  wrapped = WrapSession(transaction != null, session);&#xD;&#xA;&#xD;&#xA;  sessionStore.Store(alias, wrapped);&#xD;&#xA;&#xD;&#xA;  try&#xD;&#xA;  {&#xD;&#xA;    EnlistIfNecessary(weAreSessionOwner, transaction, wrapped);&#xD;&#xA;  }&#xD;&#xA;  catch&#xD;&#xA;  {&#xD;&#xA;    sessionStore.Remove(wrapped);&#xD;&#xA;    throw;&#xD;&#xA;  }&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;Here's the beginnings of a test case to prevent regression.&#xD;&#xA;&#xD;&#xA;_________________________________________________________________________&#xD;&#xA;&#xD;&#xA;using System;&#xD;&#xA;using System.Collections;&#xD;&#xA;using System.Data;&#xD;&#xA;using System.Data.Common;&#xD;&#xA;using Castle.Facilities.NHibernateIntegration.Internal;&#xD;&#xA;using Castle.MicroKernel;&#xD;&#xA;using Castle.Services.Transaction;&#xD;&#xA;using NHibernate;&#xD;&#xA;using NUnit.Framework;&#xD;&#xA;using Rhino.Mocks;&#xD;&#xA;using ITransaction = Castle.Services.Transaction.ITransaction;&#xD;&#xA;&#xD;&#xA;namespace Castle.Facilities.NHibernateIntegration.Tests&#xD;&#xA;{&#xD;&#xA;    [TestFixture]&#xD;&#xA;    public class DefaultSessionManagerTestCase&#xD;&#xA;    {&#xD;&#xA;        const string Alias = &quot;myAlias&quot;;&#xD;&#xA;        const string InterceptorFormatString = &quot;nhibernate.session.interceptor.{0}&quot;;&#xD;&#xA;        const string InterceptorName = &quot;nhibernate.session.interceptor&quot;;&#xD;&#xA;        const IsolationMode DefaultIsolationMode = IsolationMode.ReadUncommitted;&#xD;&#xA;        const IsolationLevel DefaultIsolationLevel = IsolationLevel.ReadUncommitted;&#xD;&#xA;&#xD;&#xA;        MockRepository mockRepository;&#xD;&#xA;&#xD;&#xA;        ISessionStore sessionStore;&#xD;&#xA;        IKernel kernel;&#xD;&#xA;        ISessionFactoryResolver factoryResolver;&#xD;&#xA;        ITransactionManager transactionManager;&#xD;&#xA;        ITransaction transaction;&#xD;&#xA;        ISessionFactory sessionFactory;&#xD;&#xA;        ISession session;&#xD;&#xA;        IDictionary contextDictionary;&#xD;&#xA;&#xD;&#xA;        DefaultSessionManager sessionManager;&#xD;&#xA;&#xD;&#xA;        T StrictMock&lt;T&gt;()&#xD;&#xA;        {&#xD;&#xA;            return mockRepository.StrictMock&lt;T&gt;();&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        [SetUp]&#xD;&#xA;        public void SetUp()&#xD;&#xA;        {&#xD;&#xA;            mockRepository = new MockRepository();&#xD;&#xA;&#xD;&#xA;            sessionStore = StrictMock&lt;ISessionStore&gt;();&#xD;&#xA;            kernel = StrictMock&lt;IKernel&gt;();&#xD;&#xA;            factoryResolver = StrictMock&lt;ISessionFactoryResolver&gt;();&#xD;&#xA;            transactionManager = StrictMock&lt;ITransactionManager&gt;();&#xD;&#xA;            transaction = StrictMock&lt;ITransaction&gt;();&#xD;&#xA;            sessionFactory = StrictMock&lt;ISessionFactory&gt;();&#xD;&#xA;            session = StrictMock&lt;ISession&gt;();&#xD;&#xA;            contextDictionary = new Hashtable();&#xD;&#xA;&#xD;&#xA;            sessionManager = new DefaultSessionManager(sessionStore, kernel, factoryResolver);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        static void ExpectReturn(object ignored, object returnValue)&#xD;&#xA;        {&#xD;&#xA;            Expect.Call(ignored).Return(returnValue);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        static void ExpectMissingComponent(IKernel kernel, string component)&#xD;&#xA;        {&#xD;&#xA;            ExpectReturn(kernel.HasComponent(component), false);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        Exception CreateException()&#xD;&#xA;        {&#xD;&#xA;            return mockRepository.Stub&lt;DbException&gt;(&quot;A transport-level error has occurred when sending the request to the server.&quot;);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        [Test]&#xD;&#xA;        public void WhenBeginTransactionFailsSessionIsRemovedFromSessionStore()&#xD;&#xA;        {&#xD;&#xA;            using (mockRepository.Record())&#xD;&#xA;            {&#xD;&#xA;                ExpectReturn(kernel[typeof(ITransactionManager)], transactionManager);&#xD;&#xA;                ExpectReturn(transactionManager.CurrentTransaction, transaction);&#xD;&#xA;                ExpectReturn(sessionStore.FindCompatibleSession(Alias), null);&#xD;&#xA;                ExpectReturn(factoryResolver.GetSessionFactory(Alias), sessionFactory);&#xD;&#xA;                ExpectMissingComponent(kernel, string.Format(InterceptorFormatString, Alias));&#xD;&#xA;                ExpectMissingComponent(kernel, InterceptorName);&#xD;&#xA;                ExpectReturn(sessionFactory.OpenSession(), session);&#xD;&#xA;                session.FlushMode = sessionManager.DefaultFlushMode;&#xD;&#xA;                Expect.Call(transaction.Context).Return(contextDictionary).Repeat.Any();&#xD;&#xA;                ExpectReturn(transaction.DistributedTransaction, false);&#xD;&#xA;                ExpectReturn(transaction.IsolationMode, DefaultIsolationMode);&#xD;&#xA;                Expect.Call(session.BeginTransaction(DefaultIsolationLevel)).Throw(CreateException());&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            using (mockRepository.Playback())&#xD;&#xA;            {&#xD;&#xA;                try&#xD;&#xA;                {&#xD;&#xA;                    sessionManager.OpenSession(Alias);&#xD;&#xA;                    Assert.Fail(&quot;DbException not thrown&quot;);&#xD;&#xA;                }&#xD;&#xA;                catch (DbException)&#xD;&#xA;                {&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;{quote}&#xD;&#xA;to:&#xD;&#xA;{quote}&#xD;&#xA;In the current DefaultSessionManager implementation, if an exception is thrown when a session in enlisted in a transaction, the session is left in the session store. (This may occur when network connectivity to the database [SQL Server] is lost and ISession.BeginTransaction throws an exception.) This transaction fails as it should, but the problem is that all future transactions that use this session store also fail (since the zombie session stays in the session store and future transactions get the zombie session). This is particularly bad when using the TLSActivityManager and the ThreadPool, since now some arbitrary worker thread can no longer process transactions.&#xD;&#xA;&#xD;&#xA;Probably the right (99%) fix is to swap the order: enlist in transaction and then store the session (does this break anything else?).&#xD;&#xA;&#xD;&#xA;if (wrapped == null)&#xD;&#xA;{&#xD;&#xA;  session = CreateSession(alias); weAreSessionOwner = true;&#xD;&#xA;&#xD;&#xA;  wrapped = WrapSession(transaction != null, session);&#xD;&#xA;&#xD;&#xA;  EnlistIfNecessary(weAreSessionOwner, transaction, wrapped);&#xD;&#xA;&#xD;&#xA;  sessionStore.Store(alias, wrapped);&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;If swapping the order is too risky, the next best fix is to catch exceptions coming out of EnlistIfNecessary, remove the session from the session store, and rethrow.&#xD;&#xA;&#xD;&#xA;if (wrapped == null)&#xD;&#xA;{&#xD;&#xA;  session = CreateSession(alias); weAreSessionOwner = true;&#xD;&#xA;&#xD;&#xA;  wrapped = WrapSession(transaction != null, session);&#xD;&#xA;&#xD;&#xA;  sessionStore.Store(alias, wrapped);&#xD;&#xA;&#xD;&#xA;  try&#xD;&#xA;  {&#xD;&#xA;    EnlistIfNecessary(weAreSessionOwner, transaction, wrapped);&#xD;&#xA;  }&#xD;&#xA;  catch&#xD;&#xA;  {&#xD;&#xA;    sessionStore.Remove(wrapped);&#xD;&#xA;    throw;&#xD;&#xA;  }&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;Here's the beginnings of a test case to prevent regression.&#xD;&#xA;&#xD;&#xA;_________________________________________________________________________&#xD;&#xA;&#xD;&#xA;using System;&#xD;&#xA;using System.Collections;&#xD;&#xA;using System.Data;&#xD;&#xA;using System.Data.Common;&#xD;&#xA;using Castle.Facilities.NHibernateIntegration.Internal;&#xD;&#xA;using Castle.MicroKernel;&#xD;&#xA;using Castle.Services.Transaction;&#xD;&#xA;using NHibernate;&#xD;&#xA;using NUnit.Framework;&#xD;&#xA;using Rhino.Mocks;&#xD;&#xA;using ITransaction = Castle.Services.Transaction.ITransaction;&#xD;&#xA;&#xD;&#xA;namespace Castle.Facilities.NHibernateIntegration.Tests&#xD;&#xA;{&#xD;&#xA;    [TestFixture]&#xD;&#xA;    public class DefaultSessionManagerTestCase&#xD;&#xA;    {&#xD;&#xA;        const string Alias = &quot;myAlias&quot;;&#xD;&#xA;        const string InterceptorFormatString = &quot;nhibernate.session.interceptor.{0}&quot;;&#xD;&#xA;        const string InterceptorName = &quot;nhibernate.session.interceptor&quot;;&#xD;&#xA;        const IsolationMode DefaultIsolationMode = IsolationMode.ReadUncommitted;&#xD;&#xA;        const IsolationLevel DefaultIsolationLevel = IsolationLevel.ReadUncommitted;&#xD;&#xA;&#xD;&#xA;        MockRepository mockRepository;&#xD;&#xA;&#xD;&#xA;        ISessionStore sessionStore;&#xD;&#xA;        IKernel kernel;&#xD;&#xA;        ISessionFactoryResolver factoryResolver;&#xD;&#xA;        ITransactionManager transactionManager;&#xD;&#xA;        ITransaction transaction;&#xD;&#xA;        ISessionFactory sessionFactory;&#xD;&#xA;        ISession session;&#xD;&#xA;        IDictionary contextDictionary;&#xD;&#xA;&#xD;&#xA;        DefaultSessionManager sessionManager;&#xD;&#xA;&#xD;&#xA;        T StrictMock&lt;T&gt;()&#xD;&#xA;        {&#xD;&#xA;            return mockRepository.StrictMock&lt;T&gt;();&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        [SetUp]&#xD;&#xA;        public void SetUp()&#xD;&#xA;        {&#xD;&#xA;            mockRepository = new MockRepository();&#xD;&#xA;&#xD;&#xA;            sessionStore = StrictMock&lt;ISessionStore&gt;();&#xD;&#xA;            kernel = StrictMock&lt;IKernel&gt;();&#xD;&#xA;            factoryResolver = StrictMock&lt;ISessionFactoryResolver&gt;();&#xD;&#xA;            transactionManager = StrictMock&lt;ITransactionManager&gt;();&#xD;&#xA;            transaction = StrictMock&lt;ITransaction&gt;();&#xD;&#xA;            sessionFactory = StrictMock&lt;ISessionFactory&gt;();&#xD;&#xA;            session = StrictMock&lt;ISession&gt;();&#xD;&#xA;            contextDictionary = new Hashtable();&#xD;&#xA;&#xD;&#xA;            sessionManager = new DefaultSessionManager(sessionStore, kernel, factoryResolver);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        static void ExpectReturn(object ignored, object returnValue)&#xD;&#xA;        {&#xD;&#xA;            Expect.Call(ignored).Return(returnValue);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        static void ExpectMissingComponent(IKernel kernel, string component)&#xD;&#xA;        {&#xD;&#xA;            ExpectReturn(kernel.HasComponent(component), false);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        Exception CreateException()&#xD;&#xA;        {&#xD;&#xA;            return mockRepository.Stub&lt;DbException&gt;(&quot;A transport-level error has occurred when sending the request to the server.&quot;);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        [Test]&#xD;&#xA;        public void WhenBeginTransactionFailsSessionIsRemovedFromSessionStore()&#xD;&#xA;        {&#xD;&#xA;            using (mockRepository.Record())&#xD;&#xA;            {&#xD;&#xA;                ExpectReturn(kernel[typeof(ITransactionManager)], transactionManager);&#xD;&#xA;                ExpectReturn(transactionManager.CurrentTransaction, transaction);&#xD;&#xA;                ExpectReturn(sessionStore.FindCompatibleSession(Alias), null);&#xD;&#xA;                ExpectReturn(factoryResolver.GetSessionFactory(Alias), sessionFactory);&#xD;&#xA;                ExpectMissingComponent(kernel, string.Format(InterceptorFormatString, Alias));&#xD;&#xA;                ExpectMissingComponent(kernel, InterceptorName);&#xD;&#xA;                ExpectReturn(sessionFactory.OpenSession(), session);&#xD;&#xA;                session.FlushMode = sessionManager.DefaultFlushMode;&#xD;&#xA;                Expect.Call(transaction.Context).Return(contextDictionary).Repeat.Any();&#xD;&#xA;                ExpectReturn(transaction.DistributedTransaction, false);&#xD;&#xA;                ExpectReturn(transaction.IsolationMode, DefaultIsolationMode);&#xD;&#xA;                Expect.Call(session.BeginTransaction(DefaultIsolationLevel)).Throw(CreateException());&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            using (mockRepository.Playback())&#xD;&#xA;            {&#xD;&#xA;                try&#xD;&#xA;                {&#xD;&#xA;                    sessionManager.OpenSession(Alias);&#xD;&#xA;                    Assert.Fail(&quot;DbException not thrown&quot;);&#xD;&#xA;                }&#xD;&#xA;                catch (DbException)&#xD;&#xA;                {&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;This test also points out that we need to pull out some constants from the main DefaultSessionManager code.&#xD;&#xA;{quote}&#xD;&#xA;" created="1219992120000" />
    <comment author="aaron.armstrong.sungard" text="* '''Importance''' changed from ''Medium'' to ''High''.&#xD;&#xA;" created="1228485300000" />
    <comment author="tehlike" text="* '''Resolution''' set to ''Fixed''.&#xD;&#xA;* '''Version Fixed''' set to ''Future''.&#xD;&#xA;* '''Status''' changed from ''Open'' to ''Resolved''.&#xD;&#xA;" created="1231910760000" />
    <comment author="tehlike" text="* '''Status''' changed from ''Resolved'' to ''Closed''.&#xD;&#xA;" created="1231910760000" />
  </issue>
</issues>